
# Strategy 패턴 (전략 패턴)

## 개요
Strategy 패턴은 행동 디자인 패턴 중 하나로, 실행 중에 알고리즘을 선택할 수 있게 하는 패턴입니다. 동일한 문제를 해결하는 여러 가지 방법(전략)을 캡슐화하고, 런타임에 적절한 전략을 선택하여 사용할 수 있게 해줍니다.

## 핵심 개념
- **알고리즘 캡슐화**: 각각의 알고리즘을 별도의 클래스로 캡슐화
- **상호 교환 가능**: 런타임에 알고리즘을 동적으로 변경 가능
- **확장성**: 새로운 전략 추가가 기존 코드 수정 없이 가능

## 구조
┌─────────┐
│ Context │
└────┬────┘
     │ (has-a)
     ↓
┌────────────────────┐
│ Strategy Interface │
└─────────▲──────────┘
          │ (is implemented by)
┌─────────┴─────────┐
│                   │
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│ConcreteStrategyA│ │ConcreteStrategyB│ │ConcreteStrategyC│
└─────────────────┘ └─────────────────┘ └─────────────────┘


## 구성 요소

### 1. Strategy (전략 인터페이스)
- 모든 구체적인 전략이 구현해야 하는 공통 인터페이스
- 컨텍스트가 전략을 실행하기 위해 사용하는 메서드 정의

### 2. ConcreteStrategy (구체적 전략)
- Strategy 인터페이스를 구현하는 실제 알고리즘 클래스들
- 각각 다른 방식으로 동일한 작업 수행

### 3. Context (컨텍스트)
- 전략 객체에 대한 참조를 유지
- 전략 인터페이스를 통해서만 전략 객체와 통신
- 런타임에 전략을 변경할 수 있는 메서드 제공

## 장점
1. **개방-폐쇄 원칙**: 새로운 전략 추가 시 기존 코드 수정 불필요
2. **런타임 변경**: 실행 중에 알고리즘 변경 가능
3. **코드 재사용**: 전략들을 다른 컨텍스트에서도 재사용 가능
4. **테스트 용이**: 각 전략을 독립적으로 테스트 가능
5. **조건문 제거**: 복잡한 if-else 문을 전략 클래스로 대체

## 단점
1. **클래스 수 증가**: 전략마다 별도 클래스 필요
2. **클라이언트 복잡성**: 클라이언트가 전략들의 차이점을 알아야 함
3. **오버헤드**: 간단한 알고리즘의 경우 과도한 설계일 수 있음

## 예제 설명

### ex01: 결제 시스템
- **PaymentStrategy**: 결제 방법 인터페이스
- **구체적 전략**: CreditCardPayment, PaypalPayment
- **컨텍스트**: ShoppingCart
- **사용 사례**: 쇼핑몰에서 다양한 결제 방식 선택

### ex02: 데이터 압축 시스템
- **CompressionStrategy**: 압축 알고리즘 인터페이스
- **구체적 전략**: RunLengthEncoding, SimpleReplacementCompression
- **컨텍스트**: Compressor
- **사용 사례**: 데이터 특성에 따른 최적 압축 알고리즘 선택

## 실제 사용 예시
- Java의 `Collections.sort()` - Comparator 전략
- Spring Security의 인증 전략
- 게임의 AI 행동 패턴
- 이미지 처리 필터 시스템
- 캐싱 전략 (LRU, FIFO, LFU)

## Strategy vs State 패턴
- **Strategy**: 알고리즘 선택에 중점, 외부에서 전략 변경
- **State**: 객체 상태에 따른 행동 변화, 내부 상태 전환

## 언제 사용할까?
1. 동일한 작업을 수행하는 여러 방법이 있을 때
2. 런타임에 알고리즘을 선택해야 할 때
3. 복잡한 조건문을 객체 지향적으로 대체하고 싶을 때
4. 알고리즘의 확장이 빈번할 것으로 예상될 때