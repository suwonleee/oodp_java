데코레이터 패턴 (Decorator Pattern)
1. 개요 (Overview)
데코레이터 패턴은 객체의 기존 코드를 수정하지 않고, 실행 시간에 동적으로 새로운 책임이나 기능을 덧붙이는 구조(Structural) 디자인 패턴입니다. 상속을 통해 기능을 확장하는 방식보다 더 유연한 대안으로 사용됩니다. 객체를 여러 '장식' 객체로 감싸서 행동을 조합하고 확장하는 방식입니다.

2. 핵심 비유: 커피 주문하기 ☕
이 패턴은 커피에 원하는 토핑을 추가하는 과정과 매우 유사합니다.

기본 객체 (ConcreteComponent): 아메리카노 - 아무것도 추가되지 않은 순수한 원본 객체입니다. 이 객체는 getDescription() 메서드로 "아메리카노"를, cost() 메서드로 3000원을 반환합니다.

첫 번째 장식 (Decorator): 우유 추가

MilkDecorator로 아메리카노 객체를 감쌉니다: new MilkDecorator(아메리카노)

이 우유 추가된 커피의 getDescription()을 호출하면, 먼저 감싸고 있던 아메리카노의 "아메리카노"를 가져온 뒤, 자신의 설명인 ", 우유 추가"를 덧붙여 **"아메리카노, 우유 추가"**를 반환합니다.

cost()를 호출하면, 아메리카노의 3000원에 자신의 가격 500원을 더해 3500원을 반환합니다.

두 번째 장식 (Decorator): 시럽 추가

방금 만든 우유 추가된 커피를 다시 SyrupDecorator로 감쌉니다: new SyrupDecorator(우유 추가된 커피)

이 시럽과 우유가 추가된 커피의 getDescription()을 호출하면, 감싸고 있던 우유 추가된 커피의 "아메리카노, 우유 추가"를 가져온 뒤, 자신의 설명 ", 시럽 추가"를 덧붙여 **"아메리카노, 우유 추가, 시럽 추가"**를 반환합니다.

cost()를 호출하면, 우유 추가된 커피의 3500원에 자신의 가격 300원을 더해 3800원을 반환합니다.

이처럼 원본 객체를 여러 데코레이터로 겹겹이 포장하듯이 감싸면서, 각 데코레이터가 고유의 기능을 추가하는 방식으로 동작합니다.

3. 언제 사용하는가? (When to Use?)
기능의 조합이 너무 많아 상속으로 해결하기 어려울 때 (예: 우유 커피, 시럽 커피, 우유+시럽 커피 등 클래스가 폭발적으로 증가하는 것을 방지).

기존 객체의 코드를 변경할 수 없는데(OCP 원칙) 기능을 확장해야 할 때.

객체의 특정 기능을 실행 시간에 동적으로 추가하거나 제거해야 할 때.

4. 구조 (Structure)
```aiignore
┌──────────┐      ┌───────────────────┐
│  Client  │─────>│     Component     │ (Interface)
└──────────┘      └─────────▲─────────┘
                              │ (implements)
               ┌──────────────┴──────────────┐
               │                             │
    ┌───────────────────┐         ┌───────────────────┐
    │ ConcreteComponent │         │     Decorator     │ (Abstract Class)
    └───────────────────┘         └─────────┬─────────┘
                                            │ (has-a)
                                            │
                                            │    ┌───────────┐
                                            └───>│ Component │
                                                 └───────────┘
                                                      ▲
                                                      │ (extends)
                                       ┌──────────────┴──────────────┐
                                       │                             │
                            ┌────────────────────┐      ┌────────────────────┐
                            │ ConcreteDecoratorA │      │ ConcreteDecoratorB │
                            └────────────────────┘      └────────────────────┘
```
5. 구성 요소 (Components)
Component (컴포넌트):

원본 객체와 장식(데코레이터)들이 따라야 하는 공통의 '규칙(인터페이스)'입니다. 클라이언트는 이 인터페이스 타입만 알고 객체를 사용합니다. (비유: 모든 커피 메뉴가 따라야 하는 Coffee라는 규칙)

ConcreteComponent (구체적인 컴포넌트):

장식의 대상이 되는 '원본' 객체입니다. (비유: PlainCoffee, 즉 순수한 아메리카노)

Decorator (데코레이터):

모든 구체적인 장식 클래스들(ConcreteDecorator)의 부모가 되는 추상 클래스입니다.

Component 인터페이스를 구현하며(is-a 관계), 내부에 다른 Component 객체를 감쌀 수 있도록 참조(has-a 관계)합니다. (비유: 우유, 시럽 등 모든 '토핑'의 기본이 되는 CoffeeDecorator)

ConcreteDecorator (구체적인 데코레이터):

Decorator를 상속받아, 실제로 새로운 책임(기능)을 추가하는 클래스입니다. 감싸고 있는 객체의 원래 기능에 자신의 기능을 덧붙입니다. (비유: MilkDecorator, SyrupDecorator처럼 실제 '우유'나 '시럽'을 추가하는 구체적인 토핑)

6. 장점 및 단점
장점
기존 코드를 수정하지 않고 기능을 확장할 수 있습니다 (개방-폐쇄 원칙, OCP).

상속을 남용하여 발생하는 '클래스 폭발'을 막고, 기능의 조합을 유연하게 만들 수 있습니다.

여러 기능을 동적으로 조합하거나, 특정 책임을 런타임에 제거하는 것도 가능합니다.

단점
자잘한 클래스들이 많아져 코드 구조가 복잡해질 수 있습니다.

데코레이터가 여러 겹으로 쌓이면, 특정 객체의 정체성을 확인하기 어렵고 디버깅이 까다로울 수 있습니다.