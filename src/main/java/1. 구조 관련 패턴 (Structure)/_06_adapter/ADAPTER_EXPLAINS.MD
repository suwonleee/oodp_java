
## 구성 요소

### 1. Target (타겟 인터페이스)
- 클라이언트가 사용하고자 하는 도메인 특화 인터페이스
- 클라이언트가 기대하는 메서드들을 정의

### 2. Adaptee (피어댑티)
- 어댑터가 감쌀 기존 클래스
- 이미 구현되어 있지만 클라이언트가 원하는 인터페이스와 다름
- 보통 레거시 코드나 외부 라이브러리

### 3. Adapter (어댑터)
- Target 인터페이스를 구현하는 클래스
- Adaptee를 내부에 포함하고 인터페이스를 변환
- 클라이언트 요청을 Adaptee가 이해할 수 있는 형태로 변환

### 4. Client (클라이언트)
- Target 인터페이스를 사용하는 코드
- Adapter를 통해 Adaptee의 기능을 사용

## 어댑터 패턴의 두 가지 형태

### 1. Object Adapter (객체 어댑터)
- **컴포지션 사용**: Adapter가 Adaptee 객체를 포함
- **유연성**: 런타임에 어댑터 교체 가능
- **다중 상속 불가 언어에서 사용**: Java, C# 등

### 2. Class Adapter (클래스 어댑터)
- **다중 상속 사용**: Target과 Adaptee를 모두 상속
- **직접적 접근**: Adaptee의 protected 멤버에 접근 가능
- **다중 상속 가능 언어에서 사용**: C++ 등

## 장점
1. **코드 재사용**: 기존 코드를 수정하지 않고 재사용 가능
2. **관심사 분리**: 인터페이스 변환 로직을 별도로 분리
3. **개방-폐쇄 원칙**: 기존 코드는 수정하지 않고 새로운 기능 확장
4. **레거시 시스템 통합**: 오래된 시스템과 새로운 시스템의 연결
5. **외부 라이브러리 통합**: 서드파티 라이브러리를 프로젝트에 쉽게 통합

## 단점
1. **코드 복잡성 증가**: 추가적인 어댑터 클래스들로 인한 복잡성
2. **성능 오버헤드**: 추가적인 메서드 호출 계층
3. **간접성**: 직접적인 호출보다 한 단계 더 거쳐야 함

## 사용 시기
1. **레거시 코드 통합**: 기존 코드를 새로운 인터페이스에 맞춰 사용할 때
2. **외부 라이브러리 통합**: 서드파티 라이브러리를 프로젝트 인터페이스에 맞춰 사용할 때
3. **인터페이스 불일치**: 두 클래스의 인터페이스가 다르지만 함께 사용해야 할 때
4. **코드 수정 불가**: 기존 코드를 직접 수정할 수 없는 상황

## 실제 사용 예시
- **Java I/O**: `InputStreamReader`는 `InputStream`을 `Reader`로 변환
- **Collections Framework**: `Arrays.asList()`는 배열을 List로 변환
- **JDBC Driver**: 각 데이터베이스의 드라이버가 표준 JDBC 인터페이스를 구현
- **Spring Framework**: 다양한 ORM 프레임워크를 통합하는 어댑터들
- **Android**: 다양한 View를 RecyclerView에서 사용할 수 있게 하는 Adapter

## Facade vs Adapter 비교
| 특성 | Adapter | Facade |
|------|---------|--------|
| 목적 | 인터페이스 변환 | 인터페이스 단순화 |
| 대상 | 단일 클래스 | 여러 서브시스템 |
| 인터페이스 | 기존 인터페이스 변경 | 새로운 통합 인터페이스 |
| 사용 이유 | 호환성 문제 해결 | 복잡성 감소 |

## Decorator vs Adapter 비교
| 특성 | Adapter | Decorator |
|------|---------|-----------|
| 목적 | 인터페이스 변환 | 기능 추가 |
| 인터페이스 | 다른 인터페이스로 변환 | 동일한 인터페이스 유지 |
| 관계 | 다른 인터페이스 연결 | 동일한 인터페이스 확장 |

## 예제 설명

### ex01: 메시지 시스템 통합
- **상황**: 기존 메시지 시스템과 새로운 메시지 인터페이스 통합
- **OldMessageSender**: 기존 레거시 메시지 시스템 (Adaptee)
- **ModernMessageSender**: 새로운 메시지 인터페이스 (Target)
- **MessageAdapter**: 인터페이스를 변환하는 어댑터
- **사용 사례**: 레거시 시스템을 새로운 아키텍처에 통합

### ex02: 다중 디스플레이 어댑터 시스템
- **상황**: 다양한 디스플레이 연결 방식을 통합 인터페이스로 관리
- **VGA, HDMI, USB**: 각기 다른 디스플레이 연결 방식 (Adaptee)
- **DisplayAdapter**: 통합 디스플레이 인터페이스 (Target)
- **VGAAdapter, HDMIAdapter, USBAdapter**: 각각의 어댑터들
- **사용 사례**: 하드웨어 인터페이스 통합 및 추상화

## 패턴 조합
- **Factory + Adapter**: 적절한 어댑터를 생성하는 팩토리
- **Strategy + Adapter**: 다양한 알고리즘을 통합 인터페이스로 제공
- **Observer + Adapter**: 서로 다른 이벤트 시스템을 연결

## 구현 팁
1. **인터페이스 설계**: Target 인터페이스를 명확하고 직관적으로 설계
2. **에러 처리**: 변환 과정에서 발생할 수 있는 예외 상황 고려
3. **성능 고려**: 불필요한 객체 생성이나 변환 과정 최소화
4. **문서화**: 어댑터가 수행하는 변환 로직을 명확히 문서화
5. **테스트**: 다양한 입력에 대한 변환 결과 검증

## 언제 사용하지 말아야 할까?
1. **간단한 인터페이스**: 변환이 너무 간단해서 어댑터가 오버엔지니어링인 경우
2. **성능이 중요**: 추가 레이어로 인한 성능 저하가 치명적인 경우
3. **자주 변경**: Adaptee가 자주 변경되어 어댑터 유지보수가 어려운 경우
4. **직접 수정 가능**: 기존 코드를 직접 수정하는 것이 더 효율적인 경우