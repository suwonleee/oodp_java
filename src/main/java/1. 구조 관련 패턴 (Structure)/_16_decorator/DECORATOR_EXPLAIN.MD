# 1. `데코레이터 패턴 (Decorator Pattern)`

### 1. 개요 (Overview)

* **목표:** 패턴의 핵심 목적을 한두 문장으로 요약합니다.
* **내용:** "객체의 기존 코드를 수정하지 않고, 실행 시간에(동적으로) 새로운 책임이나 기능을 덧붙이는 패턴입니다. 상속을 대체할 수 있는 유연한 대안으로 사용됩니다." 와 같이 패턴을 정의합니다.

### 2. 언제 사용하는가? (When to Use?)

* **목표:** 이 패턴이 어떤 문제 상황에 유용한지 구체적인 시나리오를 제시합니다.
* **내용:**
    * 기능의 조합이 너무 많아 상속으로 해결하기 어려울 때 (예: 우유 아메리카노, 시럽 아메리카노, 우유+시럽 아메리카노... 클래스가 폭발적으로 증가).
    * 기존 객체의 코드를 변경할 수 없는데 기능을 확장해야 할 때.
    * 객체의 특정 기능(책임)을 동적으로 추가하거나 제거해야 할 때.

### 3. 구조 (Structure)

* **목표:** 패턴의 클래스 다이어그램을 마크다운으로 시각화하여 각 구성 요소의 관계를 보여줍니다.

* **내용:** `Component`, `ConcreteComponent`, `Decorator`, `ConcreteDecorator`의 관계를 보여주는 마크다운 다이어그램을 작성합니다.

  ```markdown
  ┌──────────┐      ┌───────────────────┐
  │  Client  │─────>│     Component     │ (Interface)
  └──────────┘      └─────────▲─────────┘
                            │ (implements)
             ┌──────────────┴──────────────┐
             │                             │
  ┌───────────────────┐         ┌───────────────────┐
  │ ConcreteComponent │         │     Decorator     │ (Abstract Class)
  └───────────────────┘         └─────────┬─────────┘
                                          │ (has-a)
                                          │
                                          │    ┌───────────┐
                                          └───>│ Component │
                                               └───────────┘
                                                    ▲
                                                    │ (extends)
                                     ┌──────────────┴──────────────┐
                                     │                             │
                          ┌────────────────────┐      ┌────────────────────┐
                          │ ConcreteDecoratorA │      │ ConcreteDecoratorB │
                          └────────────────────┘      └────────────────────┘
  ```

### 4. 구성 요소 (Components)

* **목표:** 다이어그램에 나온 각 요소가 무엇인지 정의합니다.
* **내용:** Component(공통 인터페이스), ConcreteComponent(원본 객체), Decorator(장식의 추상 클래스), ConcreteDecorator(실제 장식)의 역할을 각각 설명합니다.

### 5. 코드 예제 (Code Example)

* **목표:** '커피 주문하기' 비유를 실제 코드로 보여주어 구체적인 이해를 돕습니다.
* **내용:** `Coffee` 인터페이스, `PlainCoffee` 클래스, `CoffeeDecorator` 추상 클래스, `MilkDecorator`와 `SyrupDecorator` 클래스, 그리고 이들을 조합하여 사용하는 `Main` 클래스를 작성합니다.

### 6. 장점 및 단점 (Pros & Cons)

* **목표:** 패턴의 장단점을 명확히 하여 언제 사용하고 언제 피해야 할지 판단 기준을 제공합니다.
* **장점:**
    * 기존 코드를 수정하지 않고 기능을 확장할 수 있다 (OCP 원칙).
    * 상속 남용으로 인한 클래스 폭발을 막을 수 있다.
    * 여러 기능을 동적으로 조합할 수 있다.
* **단점:**
    * 자잘한 클래스들이 많아져 코드 구조가 복잡해질 수 있다.
    * 데코레이터들이 여러 겹으로 쌓이면 디버깅이 까다로울 수 있다.