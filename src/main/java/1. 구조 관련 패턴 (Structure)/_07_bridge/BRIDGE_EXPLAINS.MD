# Bridge 패턴 (브리지/다리 패턴)

## 개요
Bridge 패턴은 구조적 디자인 패턴 중 하나로, 추상화(Abstraction)와 구현(Implementation)을 분리하여 각각 독립적으로 변화할 수 있게 하는 패턴입니다. "상속보다는 구성(Composition over Inheritance)"을 실현하여 두 계층 구조를 느슨하게 결합시킵니다.

## 핵심 개념
- **추상화와 구현의 분리**: 인터페이스(추상화)와 그 구현부를 완전히 분리
- **독립적 확장**: 추상화와 구현이 서로 독립적으로 확장 가능
- **런타임 결합**: 컴파일 타임이 아닌 런타임에 구현 객체를 연결
- **컴포지션 활용**: 상속 대신 컴포지션을 사용하여 유연성 확보

## 구조
Abstraction -----> Implementor ↑ ↑ Refined Concrete Abstraction Implementor


## 구성 요소

### 1. Abstraction (추상화)
- 클라이언트가 사용하는 상위 수준의 제어 로직 정의
- Implementor에 대한 참조를 보유
- 모든 실제 작업은 Implementor 객체에 위임

### 2. RefinedAbstraction (정제된 추상화)
- Abstraction을 확장하여 구체적인 기능을 추가
- 여전히 구현 세부사항은 Implementor에 의존

### 3. Implementor (구현자)
- 실제 구현을 위한 인터페이스 정의
- Abstraction의 인터페이스와 다를 수 있음
- 구현 관련 원시 연산들만 제공

### 4. ConcreteImplementor (구체적 구현자)
- Implementor 인터페이스의 실제 구현 제공
- 플랫폼별, 기술별 구체적 구현 담당

## 장점
1. **독립적 확장성**: 추상화와 구현을 각각 독립적으로 확장
2. **런타임 구현 교체**: 실행 중에 구현 객체 변경 가능
3. **클라이언트로부터 구현 세부사항 숨김**: 구현 변경이 클라이언트에 영향 없음
4. **플랫폼 독립성**: 다양한 플랫폼에 대한 구현을 쉽게 추가
5. **상속 계층의 복잡성 감소**: 상속 대신 컴포지션 사용

## 단점
1. **초기 복잡도 증가**: 추가적인 추상화 계층으로 인한 복잡성
2. **간접 참조**: 성능상 약간의 오버헤드 발생
3. **설계 어려움**: 적절한 추상화 수준을 찾기 어려울 수 있음

## Bridge vs Adapter
| 특성 | Bridge | Adapter |
|------|--------|---------|
| 목적 | 추상화와 구현 분리 | 인터페이스 호환성 |
| 설계 시점 | 설계 초기 단계 | 설계 후 호환성 문제 해결 |
| 구조 | 계획된 분리 | 기존 코드 적응 |
| 확장성 | 양방향 독립 확장 | 단방향 인터페이스 변환 |

## 실제 사용 사례
- **GUI 프레임워크**: 플랫폼별 윈도우 시스템 구현
- **데이터베이스 드라이버**: JDBC와 각 데이터베이스별 구현
- **그래픽 라이브러리**: OpenGL, DirectX 등 다양한 렌더링 엔진
- **네트워크 통신**: TCP/UDP 등 다양한 프로토콜 구현
- **장치 드라이버**: 하드웨어별 구체적 구현

## 예제 설명

### ex01: 리모컨과 장치 제어
- **Abstraction**: Remote (리모컨의 추상적 기능)
- **RefinedAbstraction**: BasicRemote, AdvancedRemote
- **Implementor**: Device (장치 제어 인터페이스)
- **ConcreteImplementor**: TV, Radio

### ex02: 메시지 전송 시스템
- **Abstraction**: Message (메시지의 추상적 개념)
- **RefinedAbstraction**: TextMessage, EncryptedMessage
- **Implementor**: MessageSender (전송 방식 인터페이스)
- **ConcreteImplementor**: SMSSender, EmailSender

## 구현 가이드라인
1. **인터페이스 설계**: Implementor는 원시 연산만 제공
2. **책임 분리**: 추상화는 고수준 로직, 구현은 저수준 세부사항
3. **확장성 고려**: 새로운 추상화나 구현 추가를 염두에 둔 설계
4. **성능 최적화**: 필요시 구현 객체 캐싱이나 풀링 고려

## 언제 사용할까?
1. 추상화와 구현을 컴파일 타임에 바인딩하고 싶지 않을 때
2. 추상화와 구현이 모두 독립적으로 확장되어야 할 때
3. 구현의 변경이 클라이언트에 영향을 주면 안 될 때
4. 여러 플랫폼이나 기술을 지원해야 할 때
5. 상속 계층이 너무 복잡해질 가능성이 있을 때