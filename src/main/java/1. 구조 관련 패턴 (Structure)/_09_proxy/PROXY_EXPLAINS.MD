# Proxy Pattern (프록시 패턴)

## 📖 개요
Proxy 패턴은 어떤 객체에 대한 **대리자(대표자)**를 제공하여, 그 객체에 대한 접근을 제어하는 구조적 디자인 패턴입니다. 클라이언트가 실제 객체에 직접 접근하는 대신, 프록시 객체를 통해 간접적으로 접근하게 됩니다.

## 🎯 목적
- **접근 제어**: 실제 객체에 대한 접근을 제어하고 보안을 강화
- **성능 최적화**: 비용이 큰 객체의 생성을 지연시키거나 캐싱
- **부가 기능**: 로깅, 인증, 트랜잭션 관리 등의 부가 기능 제공
- **원격 접근**: 다른 주소 공간에 있는 객체에 대한 로컬 대표자 제공

## 🏗️ 구조
┌────────────────┐
│   Client.java  │
└────────┬───────┘
         │
         │ 1. Proxy를 생성하고 사용 (Uses)
         ↓
┌────────────────┐
│    Proxy.java  │──────────┐
└────────┬───────┘          │ 2. RealSubject를 제어 (Controls / Has-a)
         │                  ↓
         │ 3. Subject 인터페이스 구현 (Implements)   ┌──────────────────┐
         └───────────────────────────────>│  RealSubject.java  │
                                        └────────┬──────────┘
                                                 │ 4. Subject 인터페이스 구현 (Implements)
                                                 ↓
                                        ┌──────────────────┐
                                        │   Subject.java   │
                                        │  (Interface)     │
                                        └──────────────────┘

### 구성 요소
1. **Subject (인터페이스)**: Proxy와 RealSubject의 공통 인터페이스
2. **RealSubject**: 실제 작업을 수행하는 클래스
3. **Proxy**: RealSubject에 대한 대리자, 접근을 제어
4. **Client**: Subject 인터페이스를 통해 객체를 사용

## 🔍 Proxy 패턴의 종류

### 1. Virtual Proxy (가상 프록시)
- **목적**: 비용이 큰 객체의 생성을 지연시킴
- **특징**: 실제로 필요한 시점에 객체를 생성 (Lazy Loading)
- **예제**: 이미지 로딩, 대용량 파일 처리

### 2. Protection Proxy (보호 프록시)  
- **목적**: 객체에 대한 접근 권한을 제어
- **특징**: 인증, 권한 검사, 보안 제어
- **예제**: 은행 시스템, 보안이 중요한 리소스

### 3. Remote Proxy (원격 프록시)
- **목적**: 다른 주소 공간의 객체를 로컬에서 사용
- **특징**: 네트워크 통신을 숨김
- **예제**: RPC, 웹 서비스 클라이언트

### 4. Cache Proxy (캐시 프록시)
- **목적**: 비용이 큰 연산 결과를 캐싱
- **특징**: 같은 요청에 대해 캐시된 결과 반환
- **예제**: 웹 캐시, 데이터베이스 쿼리 캐시

## 💡 장점
1. **성능 향상**: 객체 생성 지연 및 캐싱으로 성능 개선
2. **보안 강화**: 접근 제어를 통한 보안성 증대
3. **투명성**: 클라이언트는 프록시 사용을 인식하지 못함
4. **부가 기능**: 로깅, 모니터링 등 부가 기능 쉽게 추가
5. **리소스 관리**: 메모리나 네트워크 리소스의 효율적 관리

## ⚠️ 단점
1. **복잡성 증가**: 추가적인 클래스와 레이어로 인한 복잡성
2. **응답 지연**: 프록시 레이어로 인한 약간의 지연 발생
3. **메모리 오버헤드**: 프록시 객체로 인한 추가 메모리 사용

## 🔄 Decorator vs Proxy
| 구분 | Decorator | Proxy |
|------|-----------|--------|
| **목적** | 기능 확장 | 접근 제어 |
| **객체 생성** | 클라이언트가 생성 | 프록시가 제어 |
| **관계** | 기능 추가 | 대리자 역할 |
| **생명주기** | 함께 관리 | 독립적 관리 |

## 🌟 실제 사용 사례
1. **Spring AOP**: 메소드 호출을 가로채는 프록시
2. **Hibernate**: Lazy Loading을 위한 Virtual Proxy
3. **Java RMI**: Remote Proxy를 통한 분산 객체
4. **웹 프록시 서버**: 캐싱과 보안을 위한 HTTP 프록시
5. **CDN (Content Delivery Network)**: 컨텐츠 캐싱 프록시

## 📝 구현 시 고려사항
1. **인터페이스 일관성**: Proxy와 RealSubject는 같은 인터페이스 구현
2. **생명주기 관리**: RealSubject의 생성/소멸 시점 제어
3. **예외 처리**: 프록시에서 발생할 수 있는 예외 상황 고려
4. **스레드 안전성**: 멀티스레드 환경에서의 동시성 처리
5. **성능 최적화**: 불필요한 프록시 체인 방지

## 🎯 적용 기준
다음과 같은 상황에서 Proxy 패턴을 사용하면 좋습니다:
- ✅ 객체 생성 비용이 크고, 모든 기능이 항상 필요하지 않은 경우
- ✅ 객체에 대한 접근 제어가 필요한 경우
- ✅ 원격 객체나 네트워크 리소스에 접근해야 하는 경우
- ✅ 기존 코드 변경 없이 부가 기능을 추가해야 하는 경우
- ✅ 리소스 사용을 최적화하고 싶은 경우